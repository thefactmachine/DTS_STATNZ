A <- 1:30
A
A * 2
1:14
1:9
1:9 *2
a<- 1:9 *2
sum(a)
1:9
(1:9)*5
1:500
1:-670
seq(1, 5, 0.5)
1:23 ^ 3
(1:23) ^ 3
a <- (1:23) ^ 3
a
a *2
a{2}
a[3]
x <- c(“a”, “b”, “c”, “d”)for (I in seq_along(x)) {	Print(x[i])}
x <- c(“a”, “b”, “c”, “d”)
x <- c('a', 'b', 'c', 'd')
for (I in seq_along(x)) {	Print(x[i])}
for (I in seq_along(x)) {	print(x[i])}
for (i in seq_along(x)) {	print(x[i])}
library('ggplot2')
1:89
bevs <- data.frame(cbind(name = c("Bill", "Llib"), drink = c("coffee", "tea", "cocoa", "water"), cost = seq(1:8)))
bevs
bevs$cost <- as.integer(bevs$cost)
aggregate(cost ~ name + drink, data = bevs, sum)
aggregate(cost ~ name + drink, data = bevs, mean)
library(gbm)
1:8
1:8*2
require('magrittr')
dev.off()
?dev.off
library(reshape2)
library(gridExtra)
knitr
library(knitr)
library(shinyapps)
library(shiny)
library(dplyr)
library(tidyr)
library(stringr)
x = c(12,34,23,11,34,45,12,11)
length(x)
diff(x,2)
length(diff(x,2))
1:34
15 * 30
230 * 30
2500 * 2.19
2500 * 2.19 / 4.3
140 * 8
42 + 30.5 + 40.5 + 35
148 + 40
188 * 110
1200 * 1.1
1200 * (183/155)
print("hi there")
# this is a comment
dd
1 - 0.16
0.68 /2
(0.68 /2) 0.5
(0.68 /2)  0.5
(0.68 /2) + 0.5
?rnorm
salaries <- rnorm(100, mean = 50000, sd = 10000)
median(salaries)
salaries <- rnorm(100, mean = 50000, sd = 10000)
salaries <- sort(salaries)
salaries
salaries[100] <- 1000000
median(salaries)
mean(salaries)
5601.92 + 244.96
19 * 8 * 110
l <- replicate(20, runif(sample(1:10, 1)), simplify = FALSE)
l
runif(sample(1:10, 1))
out <- vector("list", length(l))
out
seq_along(1)
l <- replicate(20, runif(sample(1:10, 1)), simplify = FALSE)#
#length(l) is 20#
# create a blank list of 20 elements#
out <- vector("list", length(l))#
# seq_along(20) is 1 .. 20
seq_along(l)
seq_len(l)
seq_len(10)
for (i in seq_along(l)) {#
  out[[i]] <- length(l[[i]])#
}
out
# now with lapply  apply length to each element of the list#
aa <- lapply(l, length)
aa
out
aa
unlist(lapply(mtcars, class))
mtcars[] <- lapply(mtcars, function(x) x / mean(x))
mtcars
rm(list = ls())#
#
l <- replicate(20, runif(sample(1:10, 1)), simplify = FALSE)#
#length(l) is 20#
# create a blank list of 20 elements#
out <- vector("list", length(l))#
# seq_along(20) is 1 .. 20#
#
for (i in seq_along(l)) {#
  out[[i]] <- length(l[[i]])#
}#
# out is a list of length 20 ... each element is the length of l#
# now with lapply  apply length to each element of the list#
aa <- lapply(l, length)#
# and now as a data.frame is a list apply to each eleent (ie column)#
# get the class of each column#
unlist(lapply(mtcars, class))#
#
# Divide each column by the mean#
mtcars_new[] <- lapply(mtcars, function(x) x / mean(x))
# Divide each column by the mean#
mtcars_new <- lapply(mtcars, function(x) x / mean(x))
mtcars_new
mtcars_new <- unlist(lapply(mtcars, function(x) x / mean(x)))
mtcars_new
mtcars_new <- data.frame((lapply(mtcars, function(x) x / mean(x))))
mtcars_new
x <- rcauchy(1000)
x
?trim
unlist(lapply(trims, function(trim) mean(x, trim = trim)))
unlist(lapply(rcauchy(1000), function(trim) mean(x, trim = trim)))
###
##    Programme Name:  	create_accommodation_7578.R#
##	#
##    Objective:      	To create a DTS accommodation export for Stats NZ#
###
###
##    Author: 		   	Mark Hatcher (Sector Trends, December, 2015)#
##					 	Using code snippets and algorithms used for exporting IVS data export#
##						(see P:\OTSP\IVS\5.Dissemination\Quarterly_production_code\IVS_NZ.stat)#
##  #
# clear everything#
rm(list = ls())#
#
# load some libaries #
library(dplyr)#
library(stringr)#
library(tidyr)#
library(xlsx)#
#
options(stringsAsFactors = FALSE)#
# do not display in scientific notation#
options(scipen=999, digits = 10)#
#
setwd('/Users/zurich/Documents/TEMP-FILES/MBIE/DTS_STATNZ')#
#
# calculates "length of stay"#
#source('functions/fn_calc_los.R')#
# creates a data.frame of column combinations for use in a group_by#
source('functions/fn_create_column_combinations.R')#
# uses column combinations to create various group_by#
source('functions/fn_create_comb_aggregates.R')#
# appends columns to a data.frame such that resultant df is always 8 columns wide#
source('functions/fn_create_df_with_all.R')#
# appends a data.frame with four columns#
source('functions/fn_create_year_end.R')#
# converts floating point number to text#
source('functions/fn_convert_to_text.R')#
# creates  yearend lookup table#
source('functions/fn_create_YE_lookup.R')#
# takes a dimension lookup and creates a dimension hierarchy#
source('functions/fn_create_dim_hierarchy.R')#
# this is a collection of statements that changes a few values so it can join with "df_purpose_lu"#
source('functions/fn_clean_trips.R')#
# this function cleans up "vw_DTSTripSpend.csv" It removes "alcohol" from "Food and Alcohol"#
source('functions/fn_clean_spend.R')#
# loads a prepares an activity classification table#
source('functions/fn_get_classification.R')#
# takes a character vector and surrounds it with quotes hi --> "hi"#
source('functions/fn_quote.R')#
# PLAN OF ATTACK =====================================================================================#
#
# PREAMBLE (data relationships)#
# relationship between df_trips & df_accomodation: a person makes a trip and...#
# stays in accomodation. When a person makes a day trip there is no need for..#
# accomodation. Therefore only "Overnight trips" are included #
# A single trip can have multiple accomodation values as a person..#
# can stay in different hotels in the same or different locations#
#
# BASIC CODE STEPS#
# LOAD and process two CSV files (Quarterly data)#
# AGGREGATE - From the quarterly data, aggregate these into quarterly year-ending summaries.#
# FILTER the year ending summaries such that only whole years are included (first 3 quarters are not included)#
# CREATE satellite tables and formats that are specifically required by Stats NZ - STATS NZ require data to be#
# in a start schema configuration.#
#
# ====================================================================================================#
#
# LOAD and Prepare data#
df_trips <- read.csv("data/vw_DTSTrips.csv", header = TRUE)#
#
df_trips <- df_trips %>% #
		select(TripIDNumber, TripYear, TripQtr, TripType, DestinationRTO, SmoothedTripWeight) %>%#
		rename(Total_Trips = SmoothedTripWeight)#
#
# convert those pesky NAs to zero.#
df_trips[is.na(df_trips$Total_Trips) == TRUE, "Total_Trips"] <- 0#
#
# This function gets an XL spreasheet and cleans some values so it matches with df_activities#
df_activity_classification <- fn_get_classification()#
#
df_activities <- read.csv("data/vw_DTSVisitActivities.csv", header = TRUE) %>%#
			select(-AnswerNumber, -LegNumber)#
#
# clean up a rogue value#
df_activities[df_activities$Activities == "Business   " ,  "Activities"] <- "Business"#
#
# append activity group to df_activies#
df_activities <- df_activities %>% #
 			inner_join(df_activity_classification, by = c("Activities" = "Activity")) %>%#
 			select(TripID, Activity_Group, Activities)#
df_combined <- inner_join(df_trips, df_activities, by = c("TripIDNumber" = "TripID"))#
#========================================================================#
# RECONCILIATION POINT. The following code snippet should reconcile to #
# P:\OTSP\SAS\DTS\Output\2010Q3\reports\Est_Qtr_Trip_Type_Purpose.xls #
# The number of trips is 8,465,427#
#
df_rec <- df_combined %>% filter(TripYear == 2010 & TripQtr == 3) %>% #
			distinct(TripIDNumber) %>% summarise(total = sum(Total_Trips))#
#
stopifnot(round(df_rec$total, 0) == 8465427)#
rm(df_rec, df_activity_classification)#
#
#========================================================================#
#=============================================================================#
# CREATE a data frame of complete years. #
#
# add 4 extra columns: (YEMar, YEJun, YESep, YEDec) These will be used in group by calculations #
df_combined <- fn_create_year_end(df_combined)#
#
# Create four data frames with unique year ending values#
df_YE_Mar <- df_combined %>% select(TripQtr, YEMar) %>% distinct() %>% rename(YE = YEMar)#
df_YE_Jun <- df_combined %>% select(TripQtr, YEJun) %>% distinct() %>% rename(YE = YEJun)#
df_YE_Sep <- df_combined %>% select(TripQtr, YESep) %>% distinct() %>% rename(YE = YESep)#
df_YE_Dec <- df_combined %>% select(TripQtr, YEDec) %>% distinct() %>% rename(YE = YEDec)#
# Stack the four data frames; include whole year values; select a single column#
df_YE_all <- bind_rows(df_YE_Mar, df_YE_Jun, df_YE_Sep, df_YE_Dec) %>%#
			group_by(YE) %>% summarise(count = n()) %>% #
			filter(count == 4) %>% select(YE)#
# clean up			#
rm(df_YE_Mar, df_YE_Jun, df_YE_Sep, df_YE_Dec)#
#=============================================================================#
# CALCULATE Quarterly aggregates and rename columns#
df_activity_qtrly <- df_combined %>% #
						select(YEMar, YEJun, YESep, YEDec, Activity_Group, Total_Trips) %>% #
						group_by(YEMar, YEJun, YESep, YEDec, Activity_Group) %>%#
						summarise(Total_Activities = sum(Total_Trips), Raw_Count = n())#
#
#=============================================================================#
# CREATE Year Ending aggregates and filter to include full ears#
#
# create a vector of 4 different columns stacked on top of each other#
YE <- c(df_activity_qtrly$YEDec, df_activity_qtrly$YESep, df_activity_qtrly$YEJun, df_activity_qtrly$YEMar)#
#
# Duplicate the same dataframe four times and stack on top of each other#
df_four_quarters <- rbind(df_activity_qtrly, df_activity_qtrly, df_activity_qtrly, df_activity_qtrly)#
df_base_aggregates <- cbind(YE, df_four_quarters) %>%#
	select(-c(YEDec, YESep, YEJun, YEMar))  %>%#
	group_by(YE, Activity_Group) %>%#
	summarise(Total_Activities = sum(Total_Activities), Raw_Count = sum(Raw_Count))  %>%  #
	filter(YE %in% df_YE_all$YE)
head(df_base_aggregates)
nrow(df_base_aggregates)
###
##    Programme Name:  	create_accommodation_7578.R#
##	#
##    Objective:      	To create a DTS accommodation export for Stats NZ#
###
###
##    Author: 		   	Mark Hatcher (Sector Trends, December, 2015)#
##					 	Using code snippets and algorithms used for exporting IVS data export#
##						(see P:\OTSP\IVS\5.Dissemination\Quarterly_production_code\IVS_NZ.stat)#
##  #
# clear everything#
rm(list = ls())#
#
# load some libaries #
library(dplyr)#
library(stringr)#
library(tidyr)#
library(xlsx)#
#
options(stringsAsFactors = FALSE)#
# do not display in scientific notation#
options(scipen=999, digits = 10)#
#
setwd('/Users/zurich/Documents/TEMP-FILES/MBIE/DTS_STATNZ')#
#
# calculates "length of stay"#
#source('functions/fn_calc_los.R')#
# creates a data.frame of column combinations for use in a group_by#
source('functions/fn_create_column_combinations.R')#
# uses column combinations to create various group_by#
source('functions/fn_create_comb_aggregates.R')#
# appends columns to a data.frame such that resultant df is always 8 columns wide#
source('functions/fn_create_df_with_all.R')#
# appends a data.frame with four columns#
source('functions/fn_create_year_end.R')#
# converts floating point number to text#
source('functions/fn_convert_to_text.R')#
# creates  yearend lookup table#
source('functions/fn_create_YE_lookup.R')#
# takes a dimension lookup and creates a dimension hierarchy#
source('functions/fn_create_dim_hierarchy.R')#
# this is a collection of statements that changes a few values so it can join with "df_purpose_lu"#
source('functions/fn_clean_trips.R')#
# this function cleans up "vw_DTSTripSpend.csv" It removes "alcohol" from "Food and Alcohol"#
source('functions/fn_clean_spend.R')#
# loads a prepares an activity classification table#
source('functions/fn_get_classification.R')#
# takes a character vector and surrounds it with quotes hi --> "hi"#
source('functions/fn_quote.R')#
# PLAN OF ATTACK =====================================================================================#
#
# PREAMBLE (data relationships)#
# relationship between df_trips & df_accomodation: a person makes a trip and...#
# stays in accomodation. When a person makes a day trip there is no need for..#
# accomodation. Therefore only "Overnight trips" are included #
# A single trip can have multiple accomodation values as a person..#
# can stay in different hotels in the same or different locations#
#
# BASIC CODE STEPS#
# LOAD and process two CSV files (Quarterly data)#
# AGGREGATE - From the quarterly data, aggregate these into quarterly year-ending summaries.#
# FILTER the year ending summaries such that only whole years are included (first 3 quarters are not included)#
# CREATE satellite tables and formats that are specifically required by Stats NZ - STATS NZ require data to be#
# in a start schema configuration.#
#
# ====================================================================================================#
#
# LOAD and Prepare data#
df_trips <- read.csv("data/vw_DTSTrips.csv", header = TRUE)#
#
df_trips <- df_trips %>% #
		select(TripIDNumber, TripYear, TripQtr, TripType, DestinationRTO, SmoothedTripWeight) %>%#
		rename(Total_Trips = SmoothedTripWeight)#
#
# convert those pesky NAs to zero.#
df_trips[is.na(df_trips$Total_Trips) == TRUE, "Total_Trips"] <- 0#
#
# This function gets an XL spreasheet and cleans some values so it matches with df_activities#
df_activity_classification <- fn_get_classification()#
#
df_activities <- read.csv("data/vw_DTSVisitActivities.csv", header = TRUE) %>%#
			select(-AnswerNumber, -LegNumber)#
#
# clean up a rogue value#
df_activities[df_activities$Activities == "Business   " ,  "Activities"] <- "Business"#
#
# append activity group to df_activies#
df_activities <- df_activities %>% #
 			inner_join(df_activity_classification, by = c("Activities" = "Activity")) %>%#
 			select(TripID, Activity_Group, Activities)#
df_combined <- inner_join(df_trips, df_activities, by = c("TripIDNumber" = "TripID"))#
#========================================================================#
# RECONCILIATION POINT. The following code snippet should reconcile to #
# P:\OTSP\SAS\DTS\Output\2010Q3\reports\Est_Qtr_Trip_Type_Purpose.xls #
# The number of trips is 8,465,427#
#
df_rec <- df_combined %>% filter(TripYear == 2010 & TripQtr == 3) %>% #
			distinct(TripIDNumber) %>% summarise(total = sum(Total_Trips))#
#
stopifnot(round(df_rec$total, 0) == 8465427)#
rm(df_rec, df_activity_classification)#
#
#========================================================================#
#=============================================================================#
# CREATE a data frame of complete years. #
#
# add 4 extra columns: (YEMar, YEJun, YESep, YEDec) These will be used in group by calculations #
df_combined <- fn_create_year_end(df_combined)#
#
# Create four data frames with unique year ending values#
df_YE_Mar <- df_combined %>% select(TripQtr, YEMar) %>% distinct() %>% rename(YE = YEMar)#
df_YE_Jun <- df_combined %>% select(TripQtr, YEJun) %>% distinct() %>% rename(YE = YEJun)#
df_YE_Sep <- df_combined %>% select(TripQtr, YESep) %>% distinct() %>% rename(YE = YESep)#
df_YE_Dec <- df_combined %>% select(TripQtr, YEDec) %>% distinct() %>% rename(YE = YEDec)#
# Stack the four data frames; include whole year values; select a single column#
df_YE_all <- bind_rows(df_YE_Mar, df_YE_Jun, df_YE_Sep, df_YE_Dec) %>%#
			group_by(YE) %>% summarise(count = n()) %>% #
			filter(count == 4) %>% select(YE)#
# clean up			#
rm(df_YE_Mar, df_YE_Jun, df_YE_Sep, df_YE_Dec)#
#=============================================================================#
# CALCULATE Quarterly aggregates and rename columns#
df_activity_qtrly <- df_combined %>% #
						select(YEMar, YEJun, YESep, YEDec, Activity_Group, Total_Trips) %>% #
						group_by(YEMar, YEJun, YESep, YEDec, Activity_Group) %>%#
						summarise(Total_Activities = sum(Total_Trips), Raw_Count = n())#
#
#=============================================================================#
# CREATE Year Ending aggregates and filter to include full ears#
#
# create a vector of 4 different columns stacked on top of each other#
YE <- c(df_activity_qtrly$YEDec, df_activity_qtrly$YESep, df_activity_qtrly$YEJun, df_activity_qtrly$YEMar)#
#
# Duplicate the same dataframe four times and stack on top of each other#
df_four_quarters <- rbind(df_activity_qtrly, df_activity_qtrly, df_activity_qtrly, df_activity_qtrly)#
df_base_aggregates <- cbind(YE, df_four_quarters) %>%#
	select(-c(YEDec, YESep, YEJun, YEMar))  %>%#
	group_by(YE, Activity_Group) %>%#
	summarise(Total_Activities = sum(Total_Activities), Raw_Count = sum(Raw_Count))  %>%  #
	filter(YE %in% df_YE_all$YE)
df_base_aggregates
sum(df_base_aggregates$Total_Activities)
df_base_aggregates %>% filter(YE == "YEDec2000") %>% summarise(total = sum(Total_Activities))
df_base_aggregates %>% filter(YE == "YEDec2000") %>% summarise(total = n())
df_base_aggregates %>% filter(YE == "YEDec2000") %>% summarise(total = sum(Total_Activities))
df_base_aggregates %>% filter(YE == "YEDec2000") %>% summarise(total = sum(Total_Activities))
nrow(df_base_aggregates)
df_base_aggregates[c(900, 2700),]
stopifnot(as.integer(df_trips %>% filter(TripYear == 2010) %>% #
	summarise(total = sum(Total_Trips))) == 44077294)#
#
# Following results in 23,330 activities (unweighted for YE 2010)#
stopifnot(as.integer(df_base_aggregates %>% filter(YE == "YEDec2010") %>% #
	summarise(total = sum(Raw_Count)) %>% select(total)) == 23330)#
# Following produces 340349 - 23330 = 317019  (total unweighted activities)#
stopifnot(df_combined %>% filter(TripYear != 2010) #
	%>% summarise(total = n()) == 317019)#
#
# This total reconciles to source data (i.e 340,349 rows)#
stopifnot(read.csv("data/vw_DTSVisitActivities.csv", header = TRUE) %>% #
	summarise(count = n()) == 340349)#
#
# After doing the calculations above we dont need the "Raw_Count" column..#
#
df_base_aggregates <- df_base_aggregates %>% select(-Raw_Count)
#=============================================================================#
# CREATE various aggregate combinations#
# There are two dimenions columns. The total number of group_by combinations of these are:#
# 2^2 = 2.  1 of these has been previously created (see 'df_base_aggregates' )...#
# the remaining 3 combinations are created below. Of these 3 combinations, 2 are created#
# programmatically using a function call. The remaining combination is created as a single line of code#
#
# Assign the measure and dimension names...these will be used for column headings and also to:#
# create values for DimensionIndex.csv and MeasureIndex.csv files and to create filenames.#
vct_dim_names <- c("Year_Ending", "Activity_Group")#
names(df_base_aggregates)[1:2] <- vct_dim_names#
#
vct_measure_names <- c("Total_Activities")#
names(df_base_aggregates)[3] <- vct_measure_names#
# Create a "summarise" clause (for multiple use later)#
lst_aggregations <- as.list(paste0("sum(", vct_measure_names,")"))#
lst_sum_clause <- setNames(lst_aggregations, vct_measure_names)#
# Sort order of the columns#
vct_col_sort <- c(vct_dim_names, vct_measure_names)#
#
# There are two columns resulting in 2^2 = 4 combinations...#
# We now create 2 of these combinations#
lst_combinations <- fn_create_column_combinations(vct_dim_names)#
#
# Create a list of data frames Each list element is a data frame#
lst_aggregations <- lapply(lst_combinations, function(x) #
	fn_create_comb_aggregates(df_base_aggregates, x, lst_sum_clause))#
# ASSERT: length(lst_aggregations) == (2^length(vct_dim_names)) - 2#
v_length <- length(vct_dim_names)#
stopifnot(length(lst_aggregations) == sum(choose(v_length, 1:(v_length-1))))#
rm(v_length)#
# Combine the list of data frames into a single data frame#
df_aggregations <- do.call(bind_rows, lst_aggregations) %>% as.data.frame()#
# ASSERT: There are no NA's that have been introducted as a result of the above#
stopifnot(nrow(df_aggregations[is.na(df_aggregations$Total_Activities),]) == 0)#
# grand totals (This is a single row grand total)#
df_totals <- df_base_aggregates %>% ungroup() %>% #
				summarise_(.dots = lst_sum_clause) %>% #
				fn_create_df_with_all(vct_dim_names, vct_col_sort)#
# clean up#
rm(fn_create_column_combinations, fn_create_comb_aggregates, fn_create_df_with_all)#
rm(fn_create_year_end, lst_aggregations, lst_sum_clause, vct_col_sort)#
#=============================================================================#
#
# Combine all aggregates into a single data frame#
df_consolidated <- bind_rows(df_base_aggregates, df_aggregations, df_totals)
sum(df_base_aggregates$Total_Activities)
###
##    Programme Name:  	create_accommodation_7578.R#
##	#
##    Objective:      	To create a DTS accommodation export for Stats NZ#
###
###
##    Author: 		   	Mark Hatcher (Sector Trends, December, 2015)#
##					 	Using code snippets and algorithms used for exporting IVS data export#
##						(see P:\OTSP\IVS\5.Dissemination\Quarterly_production_code\IVS_NZ.stat)#
##  #
# clear everything#
rm(list = ls())#
#
# load some libaries #
library(dplyr)#
library(stringr)#
library(tidyr)#
library(xlsx)#
#
options(stringsAsFactors = FALSE)#
# do not display in scientific notation#
options(scipen=999, digits = 10)#
#
setwd('/Users/zurich/Documents/TEMP-FILES/MBIE/DTS_STATNZ')#
#
# calculates "length of stay"#
#source('functions/fn_calc_los.R')#
# creates a data.frame of column combinations for use in a group_by#
source('functions/fn_create_column_combinations.R')#
# uses column combinations to create various group_by#
source('functions/fn_create_comb_aggregates.R')#
# appends columns to a data.frame such that resultant df is always 8 columns wide#
source('functions/fn_create_df_with_all.R')#
# appends a data.frame with four columns#
source('functions/fn_create_year_end.R')#
# converts floating point number to text#
source('functions/fn_convert_to_text.R')#
# creates  yearend lookup table#
source('functions/fn_create_YE_lookup.R')#
# takes a dimension lookup and creates a dimension hierarchy#
source('functions/fn_create_dim_hierarchy.R')#
# this is a collection of statements that changes a few values so it can join with "df_purpose_lu"#
source('functions/fn_clean_trips.R')#
# this function cleans up "vw_DTSTripSpend.csv" It removes "alcohol" from "Food and Alcohol"#
source('functions/fn_clean_spend.R')#
# loads a prepares an activity classification table#
source('functions/fn_get_classification.R')#
# takes a character vector and surrounds it with quotes hi --> "hi"#
source('functions/fn_quote.R')#
# PLAN OF ATTACK =====================================================================================#
#
# PREAMBLE (data relationships)#
# relationship between df_trips & df_accomodation: a person makes a trip and...#
# stays in accomodation. When a person makes a day trip there is no need for..#
# accomodation. Therefore only "Overnight trips" are included #
# A single trip can have multiple accomodation values as a person..#
# can stay in different hotels in the same or different locations#
#
# BASIC CODE STEPS#
# LOAD and process two CSV files (Quarterly data)#
# AGGREGATE - From the quarterly data, aggregate these into quarterly year-ending summaries.#
# FILTER the year ending summaries such that only whole years are included (first 3 quarters are not included)#
# CREATE satellite tables and formats that are specifically required by Stats NZ - STATS NZ require data to be#
# in a start schema configuration.#
#
# ====================================================================================================#
#
# LOAD and Prepare data#
df_trips <- read.csv("data/vw_DTSTrips.csv", header = TRUE)#
#
df_trips <- df_trips %>% #
		select(TripIDNumber, TripYear, TripQtr, TripType, DestinationRTO, SmoothedTripWeight) %>%#
		rename(Total_Trips = SmoothedTripWeight)#
#
# convert those pesky NAs to zero.#
df_trips[is.na(df_trips$Total_Trips) == TRUE, "Total_Trips"] <- 0#
#
# This function gets an XL spreasheet and cleans some values so it matches with df_activities#
df_activity_classification <- fn_get_classification()#
#
df_activities <- read.csv("data/vw_DTSVisitActivities.csv", header = TRUE) %>%#
			select(-AnswerNumber, -LegNumber)#
#
# clean up a rogue value#
df_activities[df_activities$Activities == "Business   " ,  "Activities"] <- "Business"#
#
# append activity group to df_activies#
df_activities <- df_activities %>% #
 			inner_join(df_activity_classification, by = c("Activities" = "Activity")) %>%#
 			select(TripID, Activity_Group, Activities)#
df_combined <- inner_join(df_trips, df_activities, by = c("TripIDNumber" = "TripID"))#
#========================================================================#
# RECONCILIATION POINT. The following code snippet should reconcile to #
# P:\OTSP\SAS\DTS\Output\2010Q3\reports\Est_Qtr_Trip_Type_Purpose.xls #
# The number of trips is 8,465,427#
#
df_rec <- df_combined %>% filter(TripYear == 2010 & TripQtr == 3) %>% #
			distinct(TripIDNumber) %>% summarise(total = sum(Total_Trips))#
#
stopifnot(round(df_rec$total, 0) == 8465427)#
rm(df_rec, df_activity_classification)#
#
#========================================================================#
#=============================================================================#
# CREATE a data frame of complete years. #
#
# add 4 extra columns: (YEMar, YEJun, YESep, YEDec) These will be used in group by calculations #
df_combined <- fn_create_year_end(df_combined)#
#
# Create four data frames with unique year ending values#
df_YE_Mar <- df_combined %>% select(TripQtr, YEMar) %>% distinct() %>% rename(YE = YEMar)#
df_YE_Jun <- df_combined %>% select(TripQtr, YEJun) %>% distinct() %>% rename(YE = YEJun)#
df_YE_Sep <- df_combined %>% select(TripQtr, YESep) %>% distinct() %>% rename(YE = YESep)#
df_YE_Dec <- df_combined %>% select(TripQtr, YEDec) %>% distinct() %>% rename(YE = YEDec)#
# Stack the four data frames; include whole year values; select a single column#
df_YE_all <- bind_rows(df_YE_Mar, df_YE_Jun, df_YE_Sep, df_YE_Dec) %>%#
			group_by(YE) %>% summarise(count = n()) %>% #
			filter(count == 4) %>% select(YE)#
# clean up			#
rm(df_YE_Mar, df_YE_Jun, df_YE_Sep, df_YE_Dec)#
#=============================================================================#
# CALCULATE Quarterly aggregates and rename columns#
df_activity_qtrly <- df_combined %>% #
						select(YEMar, YEJun, YESep, YEDec, Activity_Group, Total_Trips) %>% #
						group_by(YEMar, YEJun, YESep, YEDec, Activity_Group) %>%#
						summarise(Total_Activities = sum(Total_Trips), Raw_Count = n())#
#
#=============================================================================#
# CREATE Year Ending aggregates and filter to include full ears#
#
# create a vector of 4 different columns stacked on top of each other#
YE <- c(df_activity_qtrly$YEDec, df_activity_qtrly$YESep, df_activity_qtrly$YEJun, df_activity_qtrly$YEMar)#
#
# Duplicate the same dataframe four times and stack on top of each other#
df_four_quarters <- rbind(df_activity_qtrly, df_activity_qtrly, df_activity_qtrly, df_activity_qtrly)#
df_base_aggregates <- cbind(YE, df_four_quarters) %>%#
	select(-c(YEDec, YESep, YEJun, YEMar))  %>%#
	group_by(YE, Activity_Group) %>%#
	summarise(Total_Activities = sum(Total_Activities), Raw_Count = sum(Raw_Count))  %>%  #
	filter(YE %in% df_YE_all$YE)#
#=============================================================================#
#=============================================================================#
# RECONCILIATION POINT. df_base_aggregates contains quarterly year ending values#
# this means that each row is the sum of 4 quarters.  To reconcile these, four source#
# files were aggregated. The four source files were:#
#
# P:\OTSP\SAS\DTS\Output\2010Q1\reports\Est_Qtr_Trip_Type_Purpose.xls#
# P:\OTSP\SAS\DTS\Output\2010Q2\reports\Est_Qtr_Trip_Type_Purpose.xls#
# P:\OTSP\SAS\DTS\Output\2010Q3\reports\Est_Qtr_Trip_Type_Purpose.xls#
# P:\OTSP\SAS\DTS\Output\2010Q4\reports\Est_Qtr_Trip_Type_Purpose.xls#
# see summary of the above reports at this location#
# \workings\activity_YE_2010_Q4\Reconciliation_trips_to_activity.xlsx#
#
# NOTE: There are no SAS reports to directly reconcile to that record..#
# activities.#
#
# Following reconciles to 44,077,294 (total for YE 2010)#
#
stopifnot(as.integer(df_trips %>% filter(TripYear == 2010) %>% #
	summarise(total = sum(Total_Trips))) == 44077294)#
#
# Following results in 23,330 activities (unweighted for YE 2010)#
stopifnot(as.integer(df_base_aggregates %>% filter(YE == "YEDec2010") %>% #
	summarise(total = sum(Raw_Count)) %>% select(total)) == 23330)#
# Following produces 340349 - 23330 = 317019  (total unweighted activities)#
stopifnot(df_combined %>% filter(TripYear != 2010) #
	%>% summarise(total = n()) == 317019)#
#
# This total reconciles to source data (i.e 340,349 rows)#
stopifnot(read.csv("data/vw_DTSVisitActivities.csv", header = TRUE) %>% #
	summarise(count = n()) == 340349)#
#
# After doing the calculations above we dont need the "Raw_Count" column..#
#
df_base_aggregates <- df_base_aggregates %>% select(-Raw_Count)#
#
#=============================================================================#
# CREATE various aggregate combinations#
# There are two dimenions columns. The total number of group_by combinations of these are:#
# 2^2 = 2.  1 of these has been previously created (see 'df_base_aggregates' )...#
# the remaining 3 combinations are created below. Of these 3 combinations, 2 are created#
# programmatically using a function call. The remaining combination is created as a single line of code#
#
# Assign the measure and dimension names...these will be used for column headings and also to:#
# create values for DimensionIndex.csv and MeasureIndex.csv files and to create filenames.#
vct_dim_names <- c("Year_Ending", "Activity_Group")#
names(df_base_aggregates)[1:2] <- vct_dim_names#
#
vct_measure_names <- c("Total_Activities")#
names(df_base_aggregates)[3] <- vct_measure_names#
# Create a "summarise" clause (for multiple use later)#
lst_aggregations <- as.list(paste0("sum(", vct_measure_names,")"))#
lst_sum_clause <- setNames(lst_aggregations, vct_measure_names)#
# Sort order of the columns#
vct_col_sort <- c(vct_dim_names, vct_measure_names)#
#
# There are two columns resulting in 2^2 = 4 combinations...#
# We now create 2 of these combinations#
lst_combinations <- fn_create_column_combinations(vct_dim_names)#
#
# Create a list of data frames Each list element is a data frame#
lst_aggregations <- lapply(lst_combinations, function(x) #
	fn_create_comb_aggregates(df_base_aggregates, x, lst_sum_clause))#
# ASSERT: length(lst_aggregations) == (2^length(vct_dim_names)) - 2#
v_length <- length(vct_dim_names)#
stopifnot(length(lst_aggregations) == sum(choose(v_length, 1:(v_length-1))))#
rm(v_length)#
# Combine the list of data frames into a single data frame#
df_aggregations <- do.call(bind_rows, lst_aggregations) %>% as.data.frame()#
# ASSERT: There are no NA's that have been introducted as a result of the above#
stopifnot(nrow(df_aggregations[is.na(df_aggregations$Total_Activities),]) == 0)#
# grand totals (This is a single row grand total)#
df_totals <- df_base_aggregates %>% ungroup() %>% #
				summarise_(.dots = lst_sum_clause) %>% #
				fn_create_df_with_all(vct_dim_names, vct_col_sort)#
# clean up#
rm(fn_create_column_combinations, fn_create_comb_aggregates, fn_create_df_with_all)#
rm(fn_create_year_end, lst_aggregations, lst_sum_clause, vct_col_sort)#
#=============================================================================#
#
# Combine all aggregates into a single data frame#
df_consolidated <- bind_rows(df_base_aggregates, df_aggregations, df_totals)
head(df_consolidated)
df_consolidated %>% filter(Year_Ending == All)
df_consolidated %>% filter(Year_Ending == "All")
df_consolidated %>% filter(Activity_Group == "All")
.0021 * 7000
df_consolidated %>% filter(Activity_Group == "All" & Year_Ending == "All")
